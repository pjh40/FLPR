/* C++ code produced by gperf version 3.1 */
/* Command-line: gperf -S 1 -m 1000 -E -Z Smash_Hash ../../docs/Smash_Hash.gperf
 */
/* Computed positions: -k'4,7' */

#if !(                                                                         \
    (' ' == 32) && ('!' == 33) && ('"' == 34) && ('#' == 35) && ('%' == 37) && \
    ('&' == 38) && ('\'' == 39) && ('(' == 40) && (')' == 41) &&               \
    ('*' == 42) && ('+' == 43) && (',' == 44) && ('-' == 45) && ('.' == 46) && \
    ('/' == 47) && ('0' == 48) && ('1' == 49) && ('2' == 50) && ('3' == 51) && \
    ('4' == 52) && ('5' == 53) && ('6' == 54) && ('7' == 55) && ('8' == 56) && \
    ('9' == 57) && (':' == 58) && (';' == 59) && ('<' == 60) && ('=' == 61) && \
    ('>' == 62) && ('?' == 63) && ('A' == 65) && ('B' == 66) && ('C' == 67) && \
    ('D' == 68) && ('E' == 69) && ('F' == 70) && ('G' == 71) && ('H' == 72) && \
    ('I' == 73) && ('J' == 74) && ('K' == 75) && ('L' == 76) && ('M' == 77) && \
    ('N' == 78) && ('O' == 79) && ('P' == 80) && ('Q' == 81) && ('R' == 82) && \
    ('S' == 83) && ('T' == 84) && ('U' == 85) && ('V' == 86) && ('W' == 87) && \
    ('X' == 88) && ('Y' == 89) && ('Z' == 90) && ('[' == 91) &&                \
    ('\\' == 92) && (']' == 93) && ('^' == 94) && ('_' == 95) &&               \
    ('a' == 97) && ('b' == 98) && ('c' == 99) && ('d' == 100) &&               \
    ('e' == 101) && ('f' == 102) && ('g' == 103) && ('h' == 104) &&            \
    ('i' == 105) && ('j' == 106) && ('k' == 107) && ('l' == 108) &&            \
    ('m' == 109) && ('n' == 110) && ('o' == 111) && ('p' == 112) &&            \
    ('q' == 113) && ('r' == 114) && ('s' == 115) && ('t' == 116) &&            \
    ('u' == 117) && ('v' == 118) && ('w' == 119) && ('x' == 120) &&            \
    ('y' == 121) && ('z' == 122) && ('{' == 123) && ('|' == 124) &&            \
    ('}' == 125) && ('~' == 126))
/* The character set is not based on ISO-646.  */
#error                                                                         \
    "gperf generated tables don't work with this execution character set. Please report a bug to <bug-gperf@gnu.org>."
#endif

#line 3 "../../docs/Smash_Hash.gperf"

/*
   Copyright (c) 2019, Triad National Security, LLC. All rights reserved.

   This is open source software; you can redistribute it and/or modify it
   under the terms of the BSD-3 License. If software is modified to produce
   derivative works, such modified software should be clearly marked, so as
   not to confuse it with the version available from LANL. Full text of the
   BSD-3 License can be found in the LICENSE file of the repository.
*/

/*!
  \file Smash_Hash.hh
  Perfect hash function developed to split names that are actually
  adjacent keywords without a space, as per section 6.3.2.2.  This file
  was generated by GNU gperf 3.1 using the input found in
  $FLPR/docs/Smash_Hash.gperf.

  NOTE: doubleprecision is NOT included in this! The parsers handle it
        directly by combining DOUBLE PRECISION under a KW_DOUBLEPRECISION
        root.
*/
#ifndef SMASH_HASH_HH
#define SMASH_HASH_HH 1

#include <flpr/Syntax_Tags.hh>
#include <string.h>
namespace FLPR {
namespace details_ {
#line 33 "../../docs/Smash_Hash.gperf"
struct Smashed {
  char const *name;
  int tok1;
  int tok2;
  int splitpos;
};
/* maximum key range = 28, duplicates = 0 */

class Smash_Hash {
private:
  static inline unsigned int hash(const char *str, size_t len);

public:
  static struct Smashed *in_word_set(const char *str, size_t len);
};

inline unsigned int Smash_Hash::hash(const char *str, size_t len) {
  static unsigned char asso_values[] = {
      32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
      32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
      32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
      32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
      32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
      32, 32, 32, 32, 32, 32, 32, 9,  16, 6,  0,  2,  2,  9,  32, 17, 32, 32,
      32, 7,  32, 0,  10, 32, 8,  4,  0,  11, 32, 10, 32, 32, 32, 32, 32, 32,
      32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
      32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
      32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
      32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
      32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
      32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
      32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
      32, 32, 32, 32};
  unsigned int hval = len;

  switch (hval) {
  default:
    hval += asso_values[static_cast<unsigned char>(str[6])];
  /*FALLTHROUGH*/
  case 6:
  case 5:
  case 4:
    hval += asso_values[static_cast<unsigned char>(str[3])];
    break;
  }
  return hval;
}

struct Smashed *Smash_Hash::in_word_set(const char *str, size_t len) {
  enum {
    TOTAL_KEYWORDS = 25,
    MIN_WORD_LENGTH = 4,
    MAX_WORD_LENGTH = 13,
    MIN_HASH_VALUE = 4,
    MAX_HASH_VALUE = 31
  };

  static struct Smashed wordlist[] = {
#line 57 "../../docs/Smash_Hash.gperf"
      {"goto", Syntax_Tags::KW_GO, Syntax_Tags::KW_TO, 2},
#line 41 "../../docs/Smash_Hash.gperf"
      {"enddo", Syntax_Tags::KW_END, Syntax_Tags::KW_DO, 3},
#line 36 "../../docs/Smash_Hash.gperf"
      {"elseif", Syntax_Tags::KW_ELSE, Syntax_Tags::KW_IF, 4},
#line 55 "../../docs/Smash_Hash.gperf"
      {"endtype", Syntax_Tags::KW_END, Syntax_Tags::KW_TYPE, 3},
#line 43 "../../docs/Smash_Hash.gperf"
      {"endfile", Syntax_Tags::KW_END, Syntax_Tags::KW_FILE, 3},
#line 59 "../../docs/Smash_Hash.gperf"
      {"selecttype", Syntax_Tags::KW_SELECT, Syntax_Tags::KW_TYPE, 6},
#line 37 "../../docs/Smash_Hash.gperf"
      {"elsewhere", Syntax_Tags::KW_ELSE, Syntax_Tags::KW_WHERE, 4},
#line 54 "../../docs/Smash_Hash.gperf"
      {"endteam", Syntax_Tags::KW_END, Syntax_Tags::KW_TEAM, 3},
#line 51 "../../docs/Smash_Hash.gperf"
      {"endselect", Syntax_Tags::KW_END, Syntax_Tags::KW_SELECT, 3},
#line 42 "../../docs/Smash_Hash.gperf"
      {"endenum", Syntax_Tags::KW_END, Syntax_Tags::KW_ENUM, 3},
#line 40 "../../docs/Smash_Hash.gperf"
      {"endcritical", Syntax_Tags::KW_END, Syntax_Tags::KW_CRITICAL, 3},
#line 58 "../../docs/Smash_Hash.gperf"
      {"selectcase", Syntax_Tags::KW_SELECT, Syntax_Tags::KW_CASE, 6},
#line 45 "../../docs/Smash_Hash.gperf"
      {"endfunction", Syntax_Tags::KW_END, Syntax_Tags::KW_FUNCTION, 3},
#line 44 "../../docs/Smash_Hash.gperf"
      {"endforall", Syntax_Tags::KW_END, Syntax_Tags::KW_FORALL, 3},
#line 38 "../../docs/Smash_Hash.gperf"
      {"endassociate", Syntax_Tags::KW_END, Syntax_Tags::KW_ASSOCIATE, 3},
#line 46 "../../docs/Smash_Hash.gperf"
      {"endif", Syntax_Tags::KW_END, Syntax_Tags::KW_IF, 3},
#line 52 "../../docs/Smash_Hash.gperf"
      {"endsubmodule", Syntax_Tags::KW_END, Syntax_Tags::KW_SUBMODULE, 3},
#line 35 "../../docs/Smash_Hash.gperf"
      {"blockdata", Syntax_Tags::KW_BLOCK, Syntax_Tags::KW_DATA, 5},
#line 53 "../../docs/Smash_Hash.gperf"
      {"endsubroutine", Syntax_Tags::KW_END, Syntax_Tags::KW_SUBROUTINE, 3},
#line 56 "../../docs/Smash_Hash.gperf"
      {"endwhere", Syntax_Tags::KW_END, Syntax_Tags::KW_WHERE, 3},
#line 48 "../../docs/Smash_Hash.gperf"
      {"endmodule", Syntax_Tags::KW_END, Syntax_Tags::KW_MODULE, 3},
#line 49 "../../docs/Smash_Hash.gperf"
      {"endprocedure", Syntax_Tags::KW_END, Syntax_Tags::KW_PROCEDURE, 3},
#line 50 "../../docs/Smash_Hash.gperf"
      {"endprogram", Syntax_Tags::KW_END, Syntax_Tags::KW_PROGRAM, 3},
#line 39 "../../docs/Smash_Hash.gperf"
      {"endblock", Syntax_Tags::KW_END, Syntax_Tags::KW_BLOCK, 3},
#line 47 "../../docs/Smash_Hash.gperf"
      {"endinterface", Syntax_Tags::KW_END, Syntax_Tags::KW_INTERFACE, 3}};

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH) {
    unsigned int key = hash(str, len);

    if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE) {
      struct Smashed *resword;

      switch (key - 4) {
      case 0:
        resword = &wordlist[0];
        goto compare;
      case 1:
        resword = &wordlist[1];
        goto compare;
      case 4:
        resword = &wordlist[2];
        goto compare;
      case 5:
        resword = &wordlist[3];
        goto compare;
      case 7:
        resword = &wordlist[4];
        goto compare;
      case 8:
        resword = &wordlist[5];
        goto compare;
      case 9:
        resword = &wordlist[6];
        goto compare;
      case 10:
        resword = &wordlist[7];
        goto compare;
      case 11:
        resword = &wordlist[8];
        goto compare;
      case 12:
        resword = &wordlist[9];
        goto compare;
      case 13:
        resword = &wordlist[10];
        goto compare;
      case 14:
        resword = &wordlist[11];
        goto compare;
      case 15:
        resword = &wordlist[12];
        goto compare;
      case 16:
        resword = &wordlist[13];
        goto compare;
      case 17:
        resword = &wordlist[14];
        goto compare;
      case 18:
        resword = &wordlist[15];
        goto compare;
      case 19:
        resword = &wordlist[16];
        goto compare;
      case 20:
        resword = &wordlist[17];
        goto compare;
      case 21:
        resword = &wordlist[18];
        goto compare;
      case 22:
        resword = &wordlist[19];
        goto compare;
      case 23:
        resword = &wordlist[20];
        goto compare;
      case 24:
        resword = &wordlist[21];
        goto compare;
      case 25:
        resword = &wordlist[22];
        goto compare;
      case 26:
        resword = &wordlist[23];
        goto compare;
      case 27:
        resword = &wordlist[24];
        goto compare;
      }
      return 0;
    compare : {
      const char *s = resword->name;

      if (*str == *s && !strcmp(str + 1, s + 1))
        return resword;
    }
    }
  }
  return 0;
}
#line 60 "../../docs/Smash_Hash.gperf"

} // namespace details_
} // namespace FLPR

#endif
